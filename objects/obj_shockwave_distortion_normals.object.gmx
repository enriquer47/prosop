<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>sprite= spr_shockwave_distortion_normal_256; //_256

shader= shd_shockwave_distortion_normals;
u_fx_strength= shader_get_uniform(shader, "fx_strength");
u_aspect= shader_get_uniform(shader, "aspect");
u_aberration= shader_get_uniform(shader, "aberration");
u_tex_waves= shader_get_sampler_index(shader, "tex_waves");
aspect= view_wview / view_hview;
tex_waves= -1;

// wave parameters:
wave_life= 90;// life in seconds
wave_scale_max= 160 / sprite_get_width(sprite);// size in pixels in room space
enum waveparam {xx, yy, age, scale, alpha}// should be in unreferenced script rather

// create waves list which will hold lists for each active wave.
// those lists will be created in step event on click
// and will age and be deleted in step event as well
list_of_waves= ds_list_create();

// prepare waves surface
srf_waves= -1;
srf_waves_scale= aspect;//estaba a un cuarto
view_w= view_wview;
view_h= view_hview;

// turn off automatic drawing of the application surface:
application_surface_draw_enable(false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description appsrf draw: on|memory
application_surface_draw_enable(true);

if (ds_exists(list_of_waves, ds_type_list)) {
for (var w = 0; w &lt; ds_list_size(list_of_waves); w++) {
if (ds_exists(list_of_waves[|w], ds_type_list)) {
ds_list_destroy(list_of_waves[|w]);
}
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description get clicks / wave age

// WAVE BIRTH
//-----------------------------------------------------------------------------
// CREO ONDA AL PULSAR LA O POR TEMAS DE DEBUG
if (keyboard_check_pressed(ord("O"))) {
crearOnda(mouse_x,mouse_y,1000,1,1);

}

// WAVE AGE:
//-----------------------------------------------------------------------------
var wave_list_size = ds_list_size(list_of_waves);
if (wave_list_size &gt; 0) {
var w, this_wave;
for (w = 0; w &lt; wave_list_size; w++) {
this_wave = list_of_waves[|w];
this_wave[|waveparam.age]+= 0.75;

if (this_wave[|waveparam.age] &lt; wave_life) {
this_wave[|waveparam.scale]= tween_cubic_out_simple(this_wave[|waveparam.age] / wave_life) * wave_scale_max;
this_wave[|waveparam.alpha]= 1 - tween_quadratic_out_simple(this_wave[|waveparam.age] / wave_life);
} else {

ds_list_destroy(this_wave);
ds_list_delete(list_of_waves, w);
w--;
wave_list_size--;
}
}
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="74">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description MAIN


//PUEDO SOLUCIONAR LO DEL PIXEL DESPLAZADO SI SIEMPRE ESTOY CREANDO UNA ONDA EN ALGUN SITIO CONSTANTEMENTE


// just draw the application surface if the list of waves is empty.
// else draw the application surface distorted by the shader:

var wave_list_size = ds_list_size(list_of_waves);

if (wave_list_size &lt;= 0) {
draw_surface(application_surface, 0, 0);
} else {
// set values based on sliders. In a game you'd use constants inside the shader instead
var fx_strength=0.1*oPlayer.image_yscale;//VALORES PUESTOS POR MI DE PRUEBA, DEBERIAN CAMBIARSE AL CREARLA??
var aberration=0.1;
var subimage=0;

// create waves surface:
if (!surface_exists(srf_waves)) {
srf_waves = surface_create(view_w * srf_waves_scale, view_h * srf_waves_scale);
tex_waves = surface_get_texture(srf_waves);
}

texture_set_interpolation(false); //HE PROBADO A CAMBIARLO A FALSE Y SE ARREGLA LO DE LA PANTALLA BORROSA

// draw wave sprite to waves surface:
surface_set_target(srf_waves);
draw_clear_alpha($FF7F7F, 1);
draw_set_blend_mode(bm_normal);
shader_set(shd_add_normals);

var w, this_wave;
for (w = 0; w &lt; wave_list_size; w++) {
this_wave = list_of_waves[|w];
draw_sprite_ext(sprite, subimage,
(this_wave[|waveparam.xx]- view_xview[0]  ) * srf_waves_scale, //NO TIENE EN CUENTA LA VIEW EN LA QUE ESTEMOS AHORA MISMO, SOLO PILLA LA 0
(this_wave[|waveparam.yy]-view_yview[0]) * srf_waves_scale,
this_wave[|waveparam.scale] * srf_waves_scale,
this_wave[|waveparam.scale] * srf_waves_scale,
0, c_white, this_wave[|waveparam.alpha]);
}

shader_reset();
draw_set_blend_mode(bm_normal);
surface_reset_target();

// draw application surface with waves surface as 2nd texture:
shader_set(shader);
shader_set_uniform_f(u_fx_strength, fx_strength);
shader_set_uniform_f(u_aspect, aspect);
shader_set_uniform_f(u_aberration, aberration);
texture_set_stage(u_tex_waves, tex_waves);
draw_surface(application_surface, 0, 0);
shader_reset();

texture_set_interpolation(false);
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//tiene que estar vacio si o si
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
