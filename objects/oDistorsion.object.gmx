<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description Init
event_inherited();

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

corner_text	= "";			// if wanted/needed, update this in a step or draw event

click_region_gui	= true; // false: mouse click region in room space | true: mouse click region in gui space
deselectable		= false;	// Allow deselecting by clicking on the module again

//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
sprite			= spr_shockwave_distortion_normals_64; //_256

shader			= shd_shockwave_distortion_normals;
u_fx_strength	= shader_get_uniform(shader, "fx_strength");
u_aspect		= shader_get_uniform(shader, "aspect");
u_aberration	= shader_get_uniform(shader, "aberration");
u_tex_waves		= shader_get_sampler_index(shader, "tex_waves");
aspect = view_hview[0]/view_wview[0];
tex_waves		= -1;

// wave parameters:
wave_life		= 1.5 * fps;	// life in seconds
wave_scale_max	= 1600 / sprite_get_width(sprite);		// size in pixels in room space
enum waveparam {xx, yy, age, scale, alpha}				// should be in unreferenced script rather

// create waves list which will hold lists for each active wave.
// those lists will be created in step event on click
// and will age and be deleted in step event as well
list_of_waves	= ds_list_create();

// prepare waves surface
srf_waves		= -1;
srf_waves_scale	= 1/4;
view_w			=view_wview[0];
view_h			=view_hview[0];

// turn off automatic drawing of the application surface:
application_surface_draw_enable(false);

//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description appsrf draw: on|memory
application_surface_draw_enable(true);

if (ds_exists(list_of_waves, ds_type_list)) {
for (var w = 0; w &lt; ds_list_size(list_of_waves); w++) {
if (ds_exists(list_of_waves[|w], ds_type_list)) {
ds_list_destroy(list_of_waves[|w]);
}
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description get clicks / wave age

// WAVE BIRTH
//-----------------------------------------------------------------------------
// create a wave on mouse-click
if (device_mouse_check_button_pressed(0, mb_left) &amp;&amp; !global.mouse_on_gui) {
var new_wave = ds_list_create();
new_wave[|waveparam.xx]= mouse_x;
new_wave[|waveparam.yy]= mouse_y;
new_wave[|waveparam.age]= 0;
new_wave[|waveparam.scale]= 0;
new_wave[|waveparam.alpha]= 1;

ds_list_add(list_of_waves, new_wave);
}

// WAVE AGE:
//-----------------------------------------------------------------------------
var wave_list_size = ds_list_size(list_of_waves);
if (wave_list_size &gt; 0) {
var w, this_wave;
for (w = 0; w &lt; wave_list_size; w++) {
this_wave = list_of_waves[|w];
this_wave[|waveparam.age]+= 1;

if (this_wave[|waveparam.age] &lt; wave_life) {
this_wave[|waveparam.scale]= tween_cubic_out_simple(this_wave[|waveparam.age] / wave_life) * wave_scale_max;
this_wave[|waveparam.alpha]= 1 - tween_quadratic_out_simple(this_wave[|waveparam.age] / wave_life);
} else {
ds_list_destroy(this_wave);
ds_list_delete(list_of_waves, w);
w--;
wave_list_size--;
}
}
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// @description MAIN

// just draw the application surface if the list of waves is empty.
// else draw the application surface distorted by the shader:

var wave_list_size = ds_list_size(list_of_waves);

if (wave_list_size &lt;= 0) {
draw_surface(application_surface, 0, 0);
} else {
// set values based on sliders. In a game you'd use constants inside the shader instead
var fx_strength= slider_get_value(1) * 0.2 - 0.1;
var aberration= slider_get_value(2) * 2 - 1;
var subimage= toggle_get_group_active(2);

// create waves surface:
if (!surface_exists(srf_waves)) {
srf_waves = surface_create(view_w * srf_waves_scale, view_h * srf_waves_scale);
tex_waves = surface_get_texture(srf_waves);
}

texture_set_interpolation(true);

// draw wave sprite to waves surface:
surface_set_target(srf_waves);
draw_clear_alpha($FF7F7F, 1);
gpu_set_blendmode_ext(bm_dest_color, bm_src_color);
shader_set(shd_add_normals);

var w, this_wave;
//var wave_list_size = ds_list_size(list_of_waves);
for (w = 0; w &lt; wave_list_size; w++) {
this_wave = list_of_waves[|w];
draw_sprite_ext(sprite, subimage,
(this_wave[|waveparam.xx] - camera_get_view_x(view_camera[0])) * srf_waves_scale,
(this_wave[|waveparam.yy] - camera_get_view_y(view_camera[0])) * srf_waves_scale,
this_wave[|waveparam.scale] * srf_waves_scale,
this_wave[|waveparam.scale] * srf_waves_scale,
0, c_white, this_wave[|waveparam.alpha]);
}

shader_reset();
gpu_set_blendmode(bm_normal);
surface_reset_target();

// draw application surface with waves surface as 2nd texture:
shader_set(shader);
shader_set_uniform_f(u_fx_strength, fx_strength);
shader_set_uniform_f(u_aspect, aspect);
shader_set_uniform_f(u_aberration, aberration);
texture_set_stage(u_tex_waves, tex_waves);
draw_surface(application_surface, 0, 0);
shader_reset();

texture_set_interpolation(false);

// debug only: draw waves surface if toggle 0 in toggle group 1 is active:
switch (toggle_get_group_active(1)) {
case 0: break;
case 1: draw_surface_ext(srf_waves, 0, 0, 1 / srf_waves_scale, 1 / srf_waves_scale, 0, c_white, 0.8); break;
case 2: draw_surface_ext(srf_waves, 0, 0, 1, 1, 0, c_white, 1);
}

// debug only: draw waves information when space is pressed:
if (toggle_get_state(3, 0)) {
var txt1 = "wave:\nage:\nscale:\nalpha: ";
var txt2;

draw_text(10, 10, "waves: " + string(wave_list_size));
for (w = 0; w &lt; wave_list_size; w++) {
this_wave = list_of_waves[|w];
txt2 =string_format(w,0, 0) +"\n" +
string_format(this_wave[|waveparam.age],0, 0) + "\n" + 
string_format(this_wave[|waveparam.scale],0, 1) + "\n" +
string_format(this_wave[|waveparam.alpha],0, 2);
draw_text(10 + w * 120, 40, txt1);
draw_text(10 + w * 120 + 60, 40, txt2);
}
}
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
